{"ast":null,"code":"const checkForRook = (selectedSquare, square, squares) => {\n  const sameRow = selectedSquare.row === square.row;\n  const sameColumn = selectedSquare.column === square.column;\n\n  if (sameRow) {\n    var firstColumn, secondColumn;\n\n    if (selectedSquare.column < square.column) {\n      firstColumn = selectedSquare.column;\n      secondColumn = square.column;\n    } else {\n      firstColumn = square.column;\n      secondColumn = selectedSquare.column;\n    }\n\n    const availableSquares = squares.find(availableSquare => {\n      return availableSquare.row === square.row && availableSquare.column > firstColumn && availableSquare.column < secondColumn && availableSquare.piece;\n    });\n    return availableSquares ? false : true;\n  }\n\n  if (sameColumn) {\n    var firstRow, secondRow;\n\n    if (selectedSquare.row < square.row) {\n      firstRow = selectedSquare.row;\n      secondRow = square.row;\n    } else {\n      firstRow = square.row;\n      secondRow = selectedSquare.row;\n    }\n\n    const availableSquares = squares.find(availableSquare => {\n      return availableSquare.column === square.column && availableSquare.row > firstRow && availableSquare.row < secondRow && availableSquare.piece;\n    });\n    return availableSquares ? false : true;\n  }\n\n  return false;\n};\n\nconst checkForBishop = (selectedSquare, square, squares) => {\n  if (Math.abs(square.row - selectedSquare.row) !== Math.abs(square.column - selectedSquare.column)) {\n    return false;\n  }\n\n  var firstRow, secondRow, firstColumn, secondColumn;\n\n  if (selectedSquare.column < square.column) {\n    firstColumn = selectedSquare.column;\n    secondColumn = square.column;\n  } else {\n    firstColumn = square.column;\n    secondColumn = selectedSquare.column;\n  }\n\n  if (selectedSquare.row < square.row) {\n    firstRow = selectedSquare.row;\n    secondRow = square.row;\n  } else {\n    firstRow = square.row;\n    secondRow = selectedSquare.row;\n  }\n\n  const availableSquares = squares.find(availableSquare => {\n    return Math.abs(availableSquare.row - square.row) === Math.abs(availableSquare.column - square.column) && availableSquare.row > firstRow && availableSquare.row < secondRow && availableSquare.column > firstColumn && availableSquare.column < secondColumn && availableSquare.piece;\n  });\n  return availableSquares ? false : true;\n};\n\nconst checkMove = (selectedPiece, selectedSquare, piece, square, squares, kingInCheck) => {\n  if (piece) {\n    if (selectedPiece.color === piece.color) {\n      return false;\n    }\n  }\n\n  if (selectedPiece.piece === 'rook') {\n    return checkForRook(selectedSquare, square, squares);\n  }\n\n  if (selectedPiece.piece === 'knight') {\n    return Math.abs(selectedSquare.row - square.row) === 2 && Math.abs(selectedSquare.column - square.column) === 1 || Math.abs(selectedSquare.row - square.row) === 1 && Math.abs(selectedSquare.column - square.column) === 2;\n  }\n\n  if (selectedPiece.piece === 'bishop') {\n    return checkForBishop(selectedSquare, square, squares);\n  }\n\n  if (selectedPiece.piece === 'queen') {\n    return checkForRook(selectedSquare, square, squares) || checkForBishop(selectedSquare, square, squares);\n  }\n\n  if (selectedPiece.piece === 'king') {\n    if (selectedSquare.row === square.row && Math.abs(selectedSquare.column - square.column) === 1 || selectedSquare.column === square.column && Math.abs(selectedSquare.row - square.row) === 1 || Math.abs(selectedSquare.row - square.row) === 1 && Math.abs(selectedSquare.column - square.column) === 1) {\n      return true;\n    }\n\n    if (!kingInCheck && selectedPiece.hasMoved === undefined && selectedSquare.row === square.row && Math.abs(selectedSquare.column - square.column) === 2) {\n      const isLeft = selectedSquare.column - square.column > 0;\n      const rook = squares.find(availableSquare => {\n        return availableSquare.column === (isLeft ? 1 : 8) && availableSquare.row === square.row && availableSquare.piece && availableSquare.piece.piece === 'rook';\n      });\n\n      if (rook && rook.piece.hasMoved === undefined) {\n        //squares between them should not be under attack\n        const inBetweenPiece = squares.find(availableSquare => {\n          return availableSquare.row === rook.row && (isLeft ? availableSquare.column > 1 : availableSquare.column < 8) && (isLeft ? availableSquare.column < selectedSquare.column : availableSquare.column > selectedSquare.column) && availableSquare.piece;\n        });\n\n        if (inBetweenPiece) {\n          return false;\n        }\n\n        const passThroughSquare = squares.find(availableSquare => {\n          return square.row === availableSquare.row && availableSquare.column === (isLeft ? selectedSquare.column - 1 : selectedSquare.column + 1);\n        });\n        const attackingPiece = squares.find(availableSquare => {\n          return availableSquare.piece && availableSquare.piece.color !== selectedPiece.color && checkMove(availableSquare.piece, availableSquare, passThroughSquare.piece, passThroughSquare, squares);\n        });\n\n        if (attackingPiece) {\n          return false;\n        }\n\n        rook.isCastling = true;\n        selectedSquare.isCastling = true;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (selectedPiece.piece === 'pawn') {\n    const sameColumn = selectedSquare.column === square.column;\n    var rowDiff, firstRow;\n\n    if (selectedPiece.color === 'white') {\n      rowDiff = selectedSquare.row - square.row;\n      firstRow = square.row;\n    } else {\n      rowDiff = square.row - selectedSquare.row;\n      firstRow = selectedSquare.row;\n    }\n\n    if (sameColumn && rowDiff === 2) {\n      if (selectedPiece.hasMoved === undefined) {\n        const availableSquares = squares.find(availableSquare => {\n          return availableSquare.column === square.column && availableSquare.row === firstRow + 1 && availableSquare.piece;\n        });\n        return availableSquares ? false : true;\n      }\n\n      return false;\n    }\n\n    if (sameColumn && rowDiff === 1 && piece === null) {\n      return true;\n    }\n\n    if (Math.abs(selectedSquare.column - square.column) === 1 && rowDiff === 1 && piece) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\nexport default checkMove;","map":{"version":3,"sources":["/Users/ragir/Documents/chess/chess api/chess-online/chess-react/src/checkMove.js"],"names":["checkForRook","selectedSquare","square","squares","sameRow","row","sameColumn","column","firstColumn","secondColumn","availableSquares","find","availableSquare","piece","firstRow","secondRow","checkForBishop","Math","abs","checkMove","selectedPiece","kingInCheck","color","hasMoved","undefined","isLeft","rook","inBetweenPiece","passThroughSquare","attackingPiece","isCastling","rowDiff"],"mappings":"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","sourcesContent":["const checkForRook = (selectedSquare, square, squares) => {\n\n    const sameRow = selectedSquare.row === square.row\n        const sameColumn = selectedSquare.column === square.column\n\n        if(sameRow){\n            var firstColumn, secondColumn\n\n            if(selectedSquare.column < square.column){\n                firstColumn = selectedSquare.column\n                secondColumn = square.column\n            }\n            else{\n                firstColumn = square.column\n                secondColumn = selectedSquare.column\n            }\n\n            const availableSquares = squares.find((availableSquare) => {\n                return availableSquare.row === square.row && availableSquare.column > firstColumn && availableSquare.column < secondColumn && availableSquare.piece\n            })\n\n            return (availableSquares ? false : true)\n        }\n        if(sameColumn){\n            var firstRow, secondRow\n\n            if(selectedSquare.row < square.row){\n                firstRow = selectedSquare.row\n                secondRow = square.row\n            }\n            else{\n                firstRow = square.row\n                secondRow = selectedSquare.row\n            }\n\n            const availableSquares = squares.find((availableSquare) => {\n                return availableSquare.column === square.column && availableSquare.row > firstRow && availableSquare.row < secondRow && availableSquare.piece\n            })\n\n            return (availableSquares ? false : true)\n        }\n\n        return false\n}\n\nconst checkForBishop = (selectedSquare, square, squares) => {\n    if(Math.abs(square.row - selectedSquare.row) !== Math.abs(square.column - selectedSquare.column)){\n        return false\n    }\n    var firstRow, secondRow, firstColumn, secondColumn\n\n    if(selectedSquare.column < square.column){\n        firstColumn = selectedSquare.column\n        secondColumn = square.column\n    }\n    else{\n        firstColumn = square.column\n        secondColumn = selectedSquare.column\n    }\n    if(selectedSquare.row < square.row){\n        firstRow = selectedSquare.row\n        secondRow = square.row\n    }\n    else{\n        firstRow = square.row\n        secondRow = selectedSquare.row\n    }\n\n    const availableSquares = squares.find((availableSquare) => {\n        return (\n            Math.abs(availableSquare.row - square.row) === Math.abs(availableSquare.column - square.column) &&\n            availableSquare.row > firstRow && availableSquare.row < secondRow && availableSquare.column > firstColumn && availableSquare.column < secondColumn\n            && availableSquare.piece\n        )\n    })\n\n    return (availableSquares ? false : true)\n\n}\n\n\nconst checkMove = (selectedPiece, selectedSquare, piece, square, squares, kingInCheck) => {\n    if(piece){\n        if(selectedPiece.color === piece.color){\n            return false\n        }\n    }\n    if(selectedPiece.piece === 'rook'){\n        return checkForRook(selectedSquare, square, squares)        \n    }\n\n    if(selectedPiece.piece === 'knight'){\n        return (\n            (Math.abs(selectedSquare.row - square.row) === 2 && Math.abs(selectedSquare.column - square.column) === 1) ||\n            (Math.abs(selectedSquare.row - square.row) === 1 && Math.abs(selectedSquare.column - square.column) === 2)\n        )\n    }\n\n    if(selectedPiece.piece === 'bishop'){\n        return checkForBishop(selectedSquare, square, squares)\n        \n    }\n    if(selectedPiece.piece === 'queen'){\n        return checkForRook(selectedSquare, square, squares) || checkForBishop(selectedSquare, square, squares)\n    }\n    if(selectedPiece.piece === 'king'){\n\n        if((selectedSquare.row === square.row && Math.abs(selectedSquare.column - square.column) === 1) ||\n            (selectedSquare.column === square.column && Math.abs(selectedSquare.row - square.row) === 1) ||\n            (Math.abs(selectedSquare.row - square.row) === 1 && Math.abs(selectedSquare.column - square.column) === 1)){\n                return true\n        }\n\n        if(!kingInCheck && selectedPiece.hasMoved === undefined && selectedSquare.row === square.row && Math.abs(selectedSquare.column - square.column) === 2){\n            const isLeft = selectedSquare.column - square.column > 0\n            const rook =  squares.find((availableSquare) => {\n                return availableSquare.column === (isLeft ? 1 : 8) && availableSquare.row === square.row && availableSquare.piece && availableSquare.piece.piece === 'rook'\n            })\n            if(rook && rook.piece.hasMoved === undefined){\n                //squares between them should not be under attack\n                const inBetweenPiece =  squares.find((availableSquare) => {\n                    return (\n                        availableSquare.row === rook.row &&\n                        (isLeft ? (availableSquare.column > 1) : (availableSquare.column < 8)) &&\n                        (isLeft ? (availableSquare.column < selectedSquare.column) : (availableSquare.column > selectedSquare.column)) && \n                        availableSquare.piece\n                    )\n                })\n                if(inBetweenPiece){\n                    return false\n                }\n                const passThroughSquare = squares.find((availableSquare) => {\n                    return (\n                        square.row === availableSquare.row &&\n                        availableSquare.column === (isLeft ? selectedSquare.column -1 : selectedSquare.column + 1) \n                    )\n                })\n                const attackingPiece = squares.find((availableSquare) => {\n                    return availableSquare.piece && availableSquare.piece.color !== selectedPiece.color && checkMove(availableSquare.piece, availableSquare, passThroughSquare.piece, passThroughSquare, squares)\n                })\n                if(attackingPiece){\n                    return false\n                }\n                rook.isCastling = true\n                selectedSquare.isCastling = true\n                return true\n            }\n        }\n\n        return false\n    }\n    if(selectedPiece.piece === 'pawn'){\n        const sameColumn = selectedSquare.column === square.column\n        var rowDiff, firstRow\n        if(selectedPiece.color === 'white'){\n            rowDiff = selectedSquare.row - square.row\n            firstRow = square.row\n        }\n        else{\n            rowDiff = square.row - selectedSquare.row\n            firstRow = selectedSquare.row\n        }\n        if(sameColumn && rowDiff === 2){\n            if(selectedPiece.hasMoved === undefined){\n                const availableSquares = squares.find((availableSquare) => {\n                    return availableSquare.column === square.column && availableSquare.row === firstRow+1 && availableSquare.piece\n                })\n                return (availableSquares ? false : true)\n            }\n            return false\n        }\n        if(sameColumn && rowDiff === 1 && piece === null){\n            return true\n        }\n        if(Math.abs(selectedSquare.column - square.column) === 1 && rowDiff === 1 && piece){\n            return true\n        }\n        return false\n    }\n}\nexport default checkMove"]},"metadata":{},"sourceType":"module"}